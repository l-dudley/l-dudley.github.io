var x=Object.defineProperty,T=Object.defineProperties;var A=Object.getOwnPropertyDescriptors;var m=Object.getOwnPropertySymbols;var k=Object.prototype.hasOwnProperty,C=Object.prototype.propertyIsEnumerable;var D=(t,e,n)=>e in t?x(t,e,{enumerable:!0,configurable:!0,writable:!0,value:n}):t[e]=n,w=(t,e)=>{for(var n in e||(e={}))k.call(e,n)&&D(t,n,e[n]);if(m)for(var n of m(e))C.call(e,n)&&D(t,n,e[n]);return t},S=(t,e)=>T(t,A(e));const v=(t,e)=>e.some(n=>t instanceof n);let B,E;function V(){return B||(B=[IDBDatabase,IDBObjectStore,IDBIndex,IDBCursor,IDBTransaction])}function O(){return E||(E=[IDBCursor.prototype.advance,IDBCursor.prototype.continue,IDBCursor.prototype.continuePrimaryKey])}const L=new WeakMap,l=new WeakMap,j=new WeakMap,y=new WeakMap,p=new WeakMap;function N(t){const e=new Promise((n,r)=>{const o=()=>{t.removeEventListener("success",a),t.removeEventListener("error",s)},a=()=>{n(d(t.result)),o()},s=()=>{r(t.error),o()};t.addEventListener("success",a),t.addEventListener("error",s)});return e.then(n=>{n instanceof IDBCursor&&L.set(n,t)}).catch(()=>{}),p.set(e,t),e}function R(t){if(l.has(t))return;const e=new Promise((n,r)=>{const o=()=>{t.removeEventListener("complete",a),t.removeEventListener("error",s),t.removeEventListener("abort",s)},a=()=>{n(),o()},s=()=>{r(t.error||new DOMException("AbortError","AbortError")),o()};t.addEventListener("complete",a),t.addEventListener("error",s),t.addEventListener("abort",s)});l.set(t,e)}let I={get(t,e,n){if(t instanceof IDBTransaction){if(e==="done")return l.get(t);if(e==="objectStoreNames")return t.objectStoreNames||j.get(t);if(e==="store")return n.objectStoreNames[1]?void 0:n.objectStore(n.objectStoreNames[0])}return d(t[e])},set(t,e,n){return t[e]=n,!0},has(t,e){return t instanceof IDBTransaction&&(e==="done"||e==="store")?!0:e in t}};function W(t){I=t(I)}function F(t){return t===IDBDatabase.prototype.transaction&&!("objectStoreNames"in IDBTransaction.prototype)?function(e,...n){const r=t.call(b(this),e,...n);return j.set(r,e.sort?e.sort():[e]),d(r)}:O().includes(t)?function(...e){return t.apply(b(this),e),d(L.get(this))}:function(...e){return d(t.apply(b(this),e))}}function K(t){return typeof t=="function"?F(t):(t instanceof IDBTransaction&&R(t),v(t,V())?new Proxy(t,I):t)}function d(t){if(t instanceof IDBRequest)return N(t);if(y.has(t))return y.get(t);const e=K(t);return e!==t&&(y.set(t,e),p.set(e,t)),e}const b=t=>p.get(t);function z(t,e,{blocked:n,upgrade:r,blocking:o,terminated:a}={}){const s=indexedDB.open(t,e),u=d(s);return r&&s.addEventListener("upgradeneeded",c=>{r(d(s.result),c.oldVersion,c.newVersion,d(s.transaction))}),n&&s.addEventListener("blocked",()=>n()),u.then(c=>{a&&c.addEventListener("close",()=>a()),o&&c.addEventListener("versionchange",()=>o())}).catch(()=>{}),u}const $=["get","getKey","getAll","getAllKeys","count"],G=["put","add","delete","clear"],h=new Map;function M(t,e){if(!(t instanceof IDBDatabase&&!(e in t)&&typeof e=="string"))return;if(h.get(e))return h.get(e);const n=e.replace(/FromIndex$/,""),r=e!==n,o=G.includes(n);if(!(n in(r?IDBIndex:IDBObjectStore).prototype)||!(o||$.includes(n)))return;const a=async function(s,...u){const c=this.transaction(s,o?"readwrite":"readonly");let f=c.store;return r&&(f=f.index(u.shift())),(await Promise.all([f[n](...u),o&&c.done]))[0]};return h.set(e,a),a}W(t=>S(w({},t),{get:(e,n,r)=>M(e,n)||t.get(e,n,r),has:(e,n)=>!!M(e,n)||t.has(e,n)}));async function i(){return await z("ez-seat-db",3,{upgrade:async(e,n,r,o)=>{const a=()=>{e.createObjectStore("students",{keyPath:"id"})},s=()=>{e.createObjectStore("seats",{keyPath:"id"})},u=async()=>{e.createObjectStore("rosters",{keyPath:"id"}),o.objectStore("rosters").add({id:1,name:"Default"});const c=o.objectStore("students");(await c.getAll()).forEach(async P=>{let g=w({},P);g.roster=1,c.put(g)}),c.createIndex("rosterIndex","roster")};switch(n){case 0:a();case 1:s();case 2:await u()}}})}async function U(t){(await i()).add("students",t)}async function X(t){(await i()).put("students",t)}async function H(t){return await(await i()).getAllFromIndex("students","rosterIndex",t)}async function Y(){const t=await H();return t.length>0?Math.max(...t.map(n=>n.id))+1:1}async function Z(t){return await(await i()).get("students",t)}async function _(t){await(await i()).delete("students",t)}async function q(){return await(await i()).getAll("seats")}async function tt(t){const e=await i();t.forEach(async n=>{await e.getKey("seats",n.id)?await e.put("seats",n):await e.add("seats",n)})}async function et(t){const e=await i();t.forEach(async n=>{await e.delete("seats",n)})}async function J(){return await(await i()).getAll("rosters")}async function nt(){const t=await J();return t.length>0?Math.max(...t.map(n=>n.id))+1:1}async function st(t){(await i()).add("rosters",t)}export{J as a,H as b,Z as c,et as d,Y as e,_ as f,q as g,nt as h,U as i,st as j,tt as s,X as u};
