var P=Object.defineProperty,T=Object.defineProperties;var j=Object.getOwnPropertyDescriptors;var m=Object.getOwnPropertySymbols;var A=Object.prototype.hasOwnProperty,C=Object.prototype.propertyIsEnumerable;var D=(t,e,n)=>e in t?P(t,e,{enumerable:!0,configurable:!0,writable:!0,value:n}):t[e]=n,I=(t,e)=>{for(var n in e||(e={}))A.call(e,n)&&D(t,n,e[n]);if(m)for(var n of m(e))C.call(e,n)&&D(t,n,e[n]);return t},g=(t,e)=>T(t,j(e));const k=(t,e)=>e.some(n=>t instanceof n);let B,E;function v(){return B||(B=[IDBDatabase,IDBObjectStore,IDBIndex,IDBCursor,IDBTransaction])}function x(){return E||(E=[IDBCursor.prototype.advance,IDBCursor.prototype.continue,IDBCursor.prototype.continuePrimaryKey])}const M=new WeakMap,h=new WeakMap,L=new WeakMap,y=new WeakMap,p=new WeakMap;function O(t){const e=new Promise((n,s)=>{const o=()=>{t.removeEventListener("success",a),t.removeEventListener("error",r)},a=()=>{n(i(t.result)),o()},r=()=>{s(t.error),o()};t.addEventListener("success",a),t.addEventListener("error",r)});return e.then(n=>{n instanceof IDBCursor&&M.set(n,t)}).catch(()=>{}),p.set(e,t),e}function V(t){if(h.has(t))return;const e=new Promise((n,s)=>{const o=()=>{t.removeEventListener("complete",a),t.removeEventListener("error",r),t.removeEventListener("abort",r)},a=()=>{n(),o()},r=()=>{s(t.error||new DOMException("AbortError","AbortError")),o()};t.addEventListener("complete",a),t.addEventListener("error",r),t.addEventListener("abort",r)});h.set(t,e)}let l={get(t,e,n){if(t instanceof IDBTransaction){if(e==="done")return h.get(t);if(e==="objectStoreNames")return t.objectStoreNames||L.get(t);if(e==="store")return n.objectStoreNames[1]?void 0:n.objectStore(n.objectStoreNames[0])}return i(t[e])},set(t,e,n){return t[e]=n,!0},has(t,e){return t instanceof IDBTransaction&&(e==="done"||e==="store")?!0:e in t}};function W(t){l=t(l)}function N(t){return t===IDBDatabase.prototype.transaction&&!("objectStoreNames"in IDBTransaction.prototype)?function(e,...n){const s=t.call(w(this),e,...n);return L.set(s,e.sort?e.sort():[e]),i(s)}:x().includes(t)?function(...e){return t.apply(w(this),e),i(M.get(this))}:function(...e){return i(t.apply(w(this),e))}}function F(t){return typeof t=="function"?N(t):(t instanceof IDBTransaction&&V(t),k(t,v())?new Proxy(t,l):t)}function i(t){if(t instanceof IDBRequest)return O(t);if(y.has(t))return y.get(t);const e=F(t);return e!==t&&(y.set(t,e),p.set(e,t)),e}const w=t=>p.get(t);function K(t,e,{blocked:n,upgrade:s,blocking:o,terminated:a}={}){const r=indexedDB.open(t,e),u=i(r);return s&&r.addEventListener("upgradeneeded",c=>{s(i(r.result),c.oldVersion,c.newVersion,i(r.transaction))}),n&&r.addEventListener("blocked",()=>n()),u.then(c=>{a&&c.addEventListener("close",()=>a()),o&&c.addEventListener("versionchange",()=>o())}).catch(()=>{}),u}const R=["get","getKey","getAll","getAllKeys","count"],z=["put","add","delete","clear"],b=new Map;function S(t,e){if(!(t instanceof IDBDatabase&&!(e in t)&&typeof e=="string"))return;if(b.get(e))return b.get(e);const n=e.replace(/FromIndex$/,""),s=e!==n,o=z.includes(n);if(!(n in(s?IDBIndex:IDBObjectStore).prototype)||!(o||R.includes(n)))return;const a=async function(r,...u){const c=this.transaction(r,o?"readwrite":"readonly");let f=c.store;return s&&(f=f.index(u.shift())),(await Promise.all([f[n](...u),o&&c.done]))[0]};return b.set(e,a),a}W(t=>g(I({},t),{get:(e,n,s)=>S(e,n)||t.get(e,n,s),has:(e,n)=>!!S(e,n)||t.has(e,n)}));async function d(){return await K("ez-seat-db",2,{upgrade(e,n){const s=()=>{e.createObjectStore("students",{keyPath:"id"})},o=()=>{e.createObjectStore("seats",{keyPath:"id"})};switch(n){case 0:s();case 1:o()}}})}async function H(t){(await d()).add("students",t)}async function J(t){(await d()).put("students",t)}async function $(t){return await(await d()).getAll("students")}async function Q(){const t=await $();return t.length>0?Math.max(...t.map(n=>n.id))+1:1}async function U(t){return await(await d()).get("students",t)}async function X(t){await(await d()).delete("students",t)}async function Y(){return await(await d()).getAll("seats")}async function Z(t){const e=await d();t.forEach(async n=>{await e.getKey("seats",n.id)?await e.put("seats",n):await e.add("seats",n)})}async function _(t){const e=await d();t.forEach(async n=>{await e.delete("seats",n)})}export{$ as a,U as b,Q as c,_ as d,X as e,Y as g,H as i,Z as s,J as u};
