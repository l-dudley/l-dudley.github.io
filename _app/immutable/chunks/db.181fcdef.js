const C=(t,e)=>e.some(n=>t instanceof n);let M,L;function R(){return M||(M=[IDBDatabase,IDBObjectStore,IDBIndex,IDBCursor,IDBTransaction])}function k(){return L||(L=[IDBCursor.prototype.advance,IDBCursor.prototype.continue,IDBCursor.prototype.continuePrimaryKey])}const T=new WeakMap,S=new WeakMap,P=new WeakMap,m=new WeakMap,B=new WeakMap;function O(t){const e=new Promise((n,s)=>{const o=()=>{t.removeEventListener("success",d),t.removeEventListener("error",r)},d=()=>{n(w(t.result)),o()},r=()=>{s(t.error),o()};t.addEventListener("success",d),t.addEventListener("error",r)});return e.then(n=>{n instanceof IDBCursor&&T.set(n,t)}).catch(()=>{}),B.set(e,t),e}function v(t){if(S.has(t))return;const e=new Promise((n,s)=>{const o=()=>{t.removeEventListener("complete",d),t.removeEventListener("error",r),t.removeEventListener("abort",r)},d=()=>{n(),o()},r=()=>{s(t.error||new DOMException("AbortError","AbortError")),o()};t.addEventListener("complete",d),t.addEventListener("error",r),t.addEventListener("abort",r)});S.set(t,e)}let E={get(t,e,n){if(t instanceof IDBTransaction){if(e==="done")return S.get(t);if(e==="objectStoreNames")return t.objectStoreNames||P.get(t);if(e==="store")return n.objectStoreNames[1]?void 0:n.objectStore(n.objectStoreNames[0])}return w(t[e])},set(t,e,n){return t[e]=n,!0},has(t,e){return t instanceof IDBTransaction&&(e==="done"||e==="store")?!0:e in t}};function N(t){E=t(E)}function W(t){return t===IDBDatabase.prototype.transaction&&!("objectStoreNames"in IDBTransaction.prototype)?function(e,...n){const s=t.call(I(this),e,...n);return P.set(s,e.sort?e.sort():[e]),w(s)}:k().includes(t)?function(...e){return t.apply(I(this),e),w(T.get(this))}:function(...e){return w(t.apply(I(this),e))}}function F(t){return typeof t=="function"?W(t):(t instanceof IDBTransaction&&v(t),C(t,R())?new Proxy(t,E):t)}function w(t){if(t instanceof IDBRequest)return O(t);if(m.has(t))return m.get(t);const e=F(t);return e!==t&&(m.set(t,e),B.set(e,t)),e}const I=t=>B.get(t);function K(t,e,{blocked:n,upgrade:s,blocking:o,terminated:d}={}){const r=indexedDB.open(t,e),l=w(r);return s&&r.addEventListener("upgradeneeded",c=>{s(w(r.result),c.oldVersion,c.newVersion,w(r.transaction),c)}),n&&r.addEventListener("blocked",c=>n(c.oldVersion,c.newVersion,c)),l.then(c=>{d&&c.addEventListener("close",()=>d()),o&&c.addEventListener("versionchange",i=>o(i.oldVersion,i.newVersion,i))}).catch(()=>{}),l}const z=["get","getKey","getAll","getAllKeys","count"],H=["put","add","delete","clear"],D=new Map;function V(t,e){if(!(t instanceof IDBDatabase&&!(e in t)&&typeof e=="string"))return;if(D.get(e))return D.get(e);const n=e.replace(/FromIndex$/,""),s=e!==n,o=H.includes(n);if(!(n in(s?IDBIndex:IDBObjectStore).prototype)||!(o||z.includes(n)))return;const d=async function(r,...l){const c=this.transaction(r,o?"readwrite":"readonly");let i=c.store;return s&&(i=i.index(l.shift())),(await Promise.all([i[n](...l),o&&c.done]))[0]};return D.set(e,d),d}N(t=>({...t,get:(e,n,s)=>V(e,n)||t.get(e,n,s),has:(e,n)=>!!V(e,n)||t.has(e,n)}));let g;const $=new Uint8Array(16);function G(){if(!g&&(g=typeof crypto<"u"&&crypto.getRandomValues&&crypto.getRandomValues.bind(crypto),!g))throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");return g($)}const a=[];for(let t=0;t<256;++t)a.push((t+256).toString(16).slice(1));function J(t,e=0){return(a[t[e+0]]+a[t[e+1]]+a[t[e+2]]+a[t[e+3]]+"-"+a[t[e+4]]+a[t[e+5]]+"-"+a[t[e+6]]+a[t[e+7]]+"-"+a[t[e+8]]+a[t[e+9]]+"-"+a[t[e+10]]+a[t[e+11]]+a[t[e+12]]+a[t[e+13]]+a[t[e+14]]+a[t[e+15]]).toLowerCase()}const Q=typeof crypto<"u"&&crypto.randomUUID&&crypto.randomUUID.bind(crypto),A={randomUUID:Q};function f(t,e,n){if(A.randomUUID&&!e&&!t)return A.randomUUID();t=t||{};const s=t.random||(t.rng||G)();if(s[6]=s[6]&15|64,s[8]=s[8]&63|128,e){n=n||0;for(let o=0;o<16;++o)e[n+o]=s[o];return e}return J(s)}async function u(){return await K("ez-seat-db",4,{upgrade:async(e,n,s,o)=>{const d=()=>{e.createObjectStore("students",{keyPath:"id"})},r=()=>{e.createObjectStore("seats",{keyPath:"id"})},l=async()=>{e.createObjectStore("rosters",{keyPath:"id"}),o.objectStore("rosters").add({id:1,name:"Default"});const i=o.objectStore("students");(await i.getAll()).forEach(async h=>{let b={...h};b.roster=1,i.put(b)}),i.createIndex("rosterIndex","roster")},c=async()=>{const i=o.objectStore("students"),j=await i.getAll(),h=o.objectStore("seats"),b=await h.getAll(),x=o.objectStore("rosters"),U=await x.getAll();j.forEach(p=>{let y={...p};y.uuid=f(),i.put(y)}),b.forEach(p=>{let y={...p};y.uuid=f(),h.put(y)}),U.forEach(p=>{let y={...p};y.uuid=f(),x.put(y)})};switch(n){case 0:d();case 1:r();case 2:await l();case 3:await c()}}})}async function Z(t){const e=await u();t.uuid=f(),e.add("students",t)}async function _(t){(await u()).put("students",t)}async function X(t){return await(await u()).getAllFromIndex("students","rosterIndex",t)}async function q(){const t=await X();return t.length>0?Math.max(...t.map(n=>n.id))+1:1}async function tt(t){return await(await u()).get("students",t)}async function et(t){await(await u()).delete("students",t)}async function nt(){return await(await u()).getAll("seats")}async function st(t){const e=await u();t.forEach(async n=>{await e.getKey("seats",n.id)?await e.put("seats",n):(n.uuid=f(),await e.add("seats",n))})}async function ot(t){const e=await u();t.forEach(async n=>{await e.delete("seats",n)})}async function Y(){return await(await u()).getAll("rosters")}async function rt(){const t=await Y();return t.length>0?Math.max(...t.map(n=>n.id))+1:1}async function at(t){const e=await u();t.uuid=f(),e.add("rosters",t)}export{Y as a,X as b,et as c,ot as d,q as e,rt as f,nt as g,at as h,Z as i,tt as j,st as s,_ as u};
