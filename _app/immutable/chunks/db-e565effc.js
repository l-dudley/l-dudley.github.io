const M=(t,e)=>e.some(n=>t instanceof n);let g,m;function L(){return g||(g=[IDBDatabase,IDBObjectStore,IDBIndex,IDBCursor,IDBTransaction])}function j(){return m||(m=[IDBCursor.prototype.advance,IDBCursor.prototype.continue,IDBCursor.prototype.continuePrimaryKey])}const S=new WeakMap,h=new WeakMap,B=new WeakMap,w=new WeakMap,I=new WeakMap;function P(t){const e=new Promise((n,o)=>{const a=()=>{t.removeEventListener("success",c),t.removeEventListener("error",s)},c=()=>{n(u(t.result)),a()},s=()=>{o(t.error),a()};t.addEventListener("success",c),t.addEventListener("error",s)});return e.then(n=>{n instanceof IDBCursor&&S.set(n,t)}).catch(()=>{}),I.set(e,t),e}function x(t){if(h.has(t))return;const e=new Promise((n,o)=>{const a=()=>{t.removeEventListener("complete",c),t.removeEventListener("error",s),t.removeEventListener("abort",s)},c=()=>{n(),a()},s=()=>{o(t.error||new DOMException("AbortError","AbortError")),a()};t.addEventListener("complete",c),t.addEventListener("error",s),t.addEventListener("abort",s)});h.set(t,e)}let l={get(t,e,n){if(t instanceof IDBTransaction){if(e==="done")return h.get(t);if(e==="objectStoreNames")return t.objectStoreNames||B.get(t);if(e==="store")return n.objectStoreNames[1]?void 0:n.objectStore(n.objectStoreNames[0])}return u(t[e])},set(t,e,n){return t[e]=n,!0},has(t,e){return t instanceof IDBTransaction&&(e==="done"||e==="store")?!0:e in t}};function T(t){l=t(l)}function V(t){return t===IDBDatabase.prototype.transaction&&!("objectStoreNames"in IDBTransaction.prototype)?function(e,...n){const o=t.call(y(this),e,...n);return B.set(o,e.sort?e.sort():[e]),u(o)}:j().includes(t)?function(...e){return t.apply(y(this),e),u(S.get(this))}:function(...e){return u(t.apply(y(this),e))}}function A(t){return typeof t=="function"?V(t):(t instanceof IDBTransaction&&x(t),M(t,L())?new Proxy(t,l):t)}function u(t){if(t instanceof IDBRequest)return P(t);if(w.has(t))return w.get(t);const e=A(t);return e!==t&&(w.set(t,e),I.set(e,t)),e}const y=t=>I.get(t);function k(t,e,{blocked:n,upgrade:o,blocking:a,terminated:c}={}){const s=indexedDB.open(t,e),f=u(s);return o&&s.addEventListener("upgradeneeded",r=>{o(u(s.result),r.oldVersion,r.newVersion,u(s.transaction),r)}),n&&s.addEventListener("blocked",r=>n(r.oldVersion,r.newVersion,r)),f.then(r=>{c&&r.addEventListener("close",()=>c()),a&&r.addEventListener("versionchange",d=>a(d.oldVersion,d.newVersion,d))}).catch(()=>{}),f}const C=["get","getKey","getAll","getAllKeys","count"],O=["put","add","delete","clear"],b=new Map;function D(t,e){if(!(t instanceof IDBDatabase&&!(e in t)&&typeof e=="string"))return;if(b.get(e))return b.get(e);const n=e.replace(/FromIndex$/,""),o=e!==n,a=O.includes(n);if(!(n in(o?IDBIndex:IDBObjectStore).prototype)||!(a||C.includes(n)))return;const c=async function(s,...f){const r=this.transaction(s,a?"readwrite":"readonly");let d=r.store;return o&&(d=d.index(f.shift())),(await Promise.all([d[n](...f),a&&r.done]))[0]};return b.set(e,c),c}T(t=>({...t,get:(e,n,o)=>D(e,n)||t.get(e,n,o),has:(e,n)=>!!D(e,n)||t.has(e,n)}));async function i(){return await k("ez-seat-db",3,{upgrade:async(e,n,o,a)=>{const c=()=>{e.createObjectStore("students",{keyPath:"id"})},s=()=>{e.createObjectStore("seats",{keyPath:"id"})},f=async()=>{e.createObjectStore("rosters",{keyPath:"id"}),a.objectStore("rosters").add({id:1,name:"Default"});const r=a.objectStore("students");(await r.getAll()).forEach(async E=>{let p={...E};p.roster=1,r.put(p)}),r.createIndex("rosterIndex","roster")};switch(n){case 0:c();case 1:s();case 2:await f()}}})}async function W(t){(await i()).add("students",t)}async function F(t){(await i()).put("students",t)}async function N(t){return await(await i()).getAllFromIndex("students","rosterIndex",t)}async function K(){const t=await N();return t.length>0?Math.max(...t.map(n=>n.id))+1:1}async function v(t){return await(await i()).get("students",t)}async function z(t){await(await i()).delete("students",t)}async function $(){return await(await i()).getAll("seats")}async function G(t){const e=await i();t.forEach(async n=>{await e.getKey("seats",n.id)?await e.put("seats",n):await e.add("seats",n)})}async function H(t){const e=await i();t.forEach(async n=>{await e.delete("seats",n)})}async function R(){return await(await i()).getAll("rosters")}async function J(){const t=await R();return t.length>0?Math.max(...t.map(n=>n.id))+1:1}async function Q(t){(await i()).add("rosters",t)}export{R as a,N as b,z as c,H as d,K as e,J as f,$ as g,Q as h,W as i,v as j,G as s,F as u};
